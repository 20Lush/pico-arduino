\doxysection{Class List}
Here are the classes, structs, unions and interfaces with brief descriptions\+:\begin{DoxyCompactList}
\item\contentsline{section}{\mbox{\hyperlink{class_arduino_pico_tone}{Arduino\+Pico\+Tone}} \\*\mbox{\hyperlink{class_arduino_pico_tone}{Arduino\+Pico\+Tone}} provides static methods for \mbox{\hyperlink{class_pico_tone}{Pico\+Tone}} }{\pageref{class_arduino_pico_tone}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_vector_1_1iterator}{Vector$<$ T $>$\+::iterator}} \\*Iterator for the \mbox{\hyperlink{class_vector}{Vector}} class }{\pageref{class_vector_1_1iterator}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_vector_3_01_map_1_1_map_entry_3_01_k_00_01_v_01_4_01_4_1_1iterator}{Vector$<$ Map\+::\+Map\+Entry$<$ K, V $>$ $>$\+::iterator}} }{\pageref{class_vector_3_01_map_1_1_map_entry_3_01_k_00_01_v_01_4_01_4_1_1iterator}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_map}{Map$<$ K, V $>$}} \\*A simple key value map collection }{\pageref{class_map}}{}
\item\contentsline{section}{\mbox{\hyperlink{struct_map_1_1_map_entry}{Map$<$ K, V $>$\+::\+Map\+Entry$<$ KM, VM $>$}} }{\pageref{struct_map_1_1_map_entry}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_muliticore_fifo}{Muliticore\+Fifo}} \\*The RP2040 contains two FIFOs for passing data, messages or ordered events between the two cores. Each FIFO is 32 bits wide, and 8 entries deep. One of the FIFOs can only be written by core 0, and read by core 1. The other can only be written by core 1, and read by core 0 }{\pageref{class_muliticore_fifo}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_pico_default_serial}{Pico\+Default\+Serial}} \\*\mbox{\hyperlink{class_pico_default_serial}{Pico\+Default\+Serial}} is using the pico default output. It is mapped to the Arduino Serial variable }{\pageref{class_pico_default_serial}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_pico_g_p_i_o_function}{Pico\+GPIOFunction}} \\*The pico requires that the function of the pin is defined. In Arduino, there is no such concept\+: so we do this at the first call of the corresponding function\+: enum gpio\+\_\+function \{ GPIO\+\_\+\+FUNC\+\_\+\+XIP = 0, GPIO\+\_\+\+FUNC\+\_\+\+SPI = 1, GPIO\+\_\+\+FUNC\+\_\+\+UART = 2, GPIO\+\_\+\+FUNC\+\_\+\+I2C = 3, GPIO\+\_\+\+FUNC\+\_\+\+PWM = 4, GPIO\+\_\+\+FUNC\+\_\+\+SIO = 5, GPIO\+\_\+\+FUNC\+\_\+\+PIO0 = 6, GPIO\+\_\+\+FUNC\+\_\+\+PIO1 = 7, GPIO\+\_\+\+FUNC\+\_\+\+GPCK = 8, GPIO\+\_\+\+FUNC\+\_\+\+USB = 9, GPIO\+\_\+\+FUNC\+\_\+\+NULL = 0xf, \}; }{\pageref{class_pico_g_p_i_o_function}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_pico_hardware_i2_c}{Pico\+Hardware\+I2C}} \\*Arduino I2C implementation using the Pico functionality }{\pageref{class_pico_hardware_i2_c}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_pico_hardware_serial}{Pico\+Hardware\+Serial}} \\*Serial Stream for a defined UART. By default we use the following pins\+: UART0 tx/rx = gp0/gp1; UART1 tx/rx = gp4/gp5; }{\pageref{class_pico_hardware_serial}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_pico_hardware_s_p_i}{Pico\+Hardware\+SPI}} \\*Arduino Hardware\+SPI interface using the Pico API. We use the following default pins spi0\+: pin\+Rx = 16; pin\+Tx = 19; pin\+CS = 17; pin\+SCK = 18; spi1\+: pin\+Rx = 12; pin\+Tx = 11; pin\+CS = 13; pin\+SCK = 10; On the master miso = pin\+Rx and mosi = pin\+Tx }{\pageref{class_pico_hardware_s_p_i}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_pico_logger}{Pico\+Logger}} \\*A simple Logger that writes messages dependent on the log level }{\pageref{class_pico_logger}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_pico_tone}{Pico\+Tone}} \\*We use the \mbox{\hyperlink{class_timer_alarm_repeating}{Timer\+Alarm\+Repeating}} to generate tones }{\pageref{class_pico_tone}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_p_i_o_manager}{PIOManager}} \\*The PIO subsystem on RP2040 allows you to write small, simple programs for what are called PIO state machines, of which RP2040 has eight split across two PIO instances. A state machine is responsible for setting and reading one or more GPIOs, buffering data to or from the processor (or RP2040â€™s ultra-\/fast DMA subsystem), and notifying the processor, via IRQ or polling, when data or attention is needed }{\pageref{class_p_i_o_manager}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_queue}{Queue$<$ T $>$}} \\*Construct a new Pico \mbox{\hyperlink{class_queue}{Queue}} object }{\pageref{class_queue}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_semaphore}{Semaphore}} \\*Pico \mbox{\hyperlink{class_semaphore}{Semaphore}} which might be useful if you use the 2 processors (e.\+g. with the \mbox{\hyperlink{class_thread}{Thread}} class) }{\pageref{class_semaphore}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_software_serial}{Software\+Serial}} \\*Software Serial Arduino Stream which uses the Pico PIO }{\pageref{class_software_serial}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_thread}{Thread}} }{\pageref{class_thread}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_timer_alarm}{Timer\+Alarm}} \\*Alarm functions for scheduling future execution }{\pageref{class_timer_alarm}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_timer_alarm_repeating}{Timer\+Alarm\+Repeating}} \\*Repeating Timer functions for simple scheduling of repeated execution }{\pageref{class_timer_alarm_repeating}}{}
\item\contentsline{section}{\mbox{\hyperlink{class_vector}{Vector$<$ T $>$}} \\*\mbox{\hyperlink{class_vector}{Vector}} implementation which provides the most important methods as defined by std\+::vector. This is neither part of Pico nor of the Arduino framwork but nevertheless it is quite handy to have and most of the times quite better then dealing with raw c arrays }{\pageref{class_vector}}{}
\end{DoxyCompactList}
